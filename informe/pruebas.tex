\section{Pruebas y Validación}

Para verificar que el sistema funciona como esperamos, realizamos una serie de pruebas que cubren desde conectividad básica hasta validación específica de cada regla del firewall. También probamos diferentes configuraciones de topología para asegurar que el diseño escala correctamente.

\subsection{Configuración del Entorno}

El procedimiento para todas las pruebas es el mismo:

\begin{enumerate}
    \item Arrancar el controlador POX (que carga L2 learning y el firewall):
    \begin{verbatim}
    ./run_controller.sh
    \end{verbatim}
    
    \item Levantar la topología de Mininet con el número de switches deseado:
    \begin{verbatim}
    ./run_topology.sh 2
    \end{verbatim}
    
    \item Esperar unos segundos a que los switches se conecten y las reglas se instalen.
\end{enumerate}

Es importante arrancar el controlador primero, porque cuando Mininet crea los switches, estos intentan conectarse inmediatamente al controlador. Si no está corriendo, los switches quedan sin controlador y no funcionan.

\subsection{Verificación Básica de Conectividad}

Antes de probar reglas específicas, verificamos que el sistema funciona correctamente y que el firewall bloquea donde debe.

\subsubsection{Prueba 1: PingAll}

Para tener una visión general de la conectividad, ejecutamos \texttt{pingall} en Mininet:

\begin{verbatim}
mininet> pingall
\end{verbatim}

Los resultados muestran que la mayoría de los hosts se comunican correctamente, excepto h2 y h3 que tienen comunicación bloqueada por la regla del firewall.

\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{carga_reglas_logs.png}
    \caption{Logs del controlador mostrando la instalación de las 4 reglas en el switch S1}
    \label{fig:carga_reglas_logs}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.6\textwidth]{resultado_pingall.png}
    \caption{Resultado del comando pingall. Se observa conectividad completa excepto entre h2 y h3}
    \label{fig:resultado_pingall}
\end{figure}

Para confirmar que el firewall está realmente bloqueando el tráfico, capturamos tráfico en la interfaz que conecta ambos switches (s1-eth1):

\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{resultado_pingall_switches.png}
    \caption{Captura en la interfaz s1-eth1. Los pings entre h2 y h3 no atraviesan el switch, confirmando que el firewall los descarta antes de reenviarlos}
    \label{fig:resultado_pingall_switches}
\end{figure}

\subsection{Validación de Reglas Específicas del Firewall}

Las siguientes pruebas verifican cada regla configurada en el firewall, asegurando que bloquean el tráfico correcto sin afectar el resto de las comunicaciones permitidas.

\subsubsection{Prueba 2: Bloqueo de Puerto 80 (TCP y UDP) - Regla 1}

El firewall tiene dos reglas que bloquean todo el tráfico hacia el puerto 80, tanto TCP como UDP. Para verificarlo, probamos con diferentes herramientas y analizamos el tráfico capturado.
\\

\textbf{Prueba con HTTP (TCP):}
\begin{verbatim}
mininet> h1 python3 -m http.server 80 &
mininet> h4 curl -m 5 http://10.0.0.1:80
\end{verbatim}

El comando \texttt{curl} falla con timeout, confirmando que no puede establecer conexión.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{resultado_curl_h4-h1.png}
    \caption{Intento fallido de conexión HTTP desde h4 hacia h1:80}
    \label{fig:resultado_curl_h4-h1}
\end{figure}

\textbf{Prueba con iperf (TCP):}
\begin{verbatim}
mininet> h1 iperf -s -p 80 &
mininet> h4 iperf -c 10.0.0.1 -p 80 -t 5
\end{verbatim}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{resultado_iperf_h4-h1.png}
    \caption{iperf tampoco logra establecer conexión en puerto 80}
    \label{fig:resultado_iperf_h4-h1}
\end{figure}

Para realizar el análisis con Wireshark, capturamos tráfico en distintas interfaces para ver dónde se está bloqueando. En s2-eth3 (salida de h4) vemos los intentos de conexión SYN, pero en s1-eth1 (enlace entre s1 y s2, después del firewall) no aparece nada, lo que confirma que s1 está descartando los paquetes.

\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{resultado_wireshark_bloqueo_h4-h1.png}
    \caption{Captura de Wireshark mostrando paquetes SYN retransmitidos sin respuesta. El tráfico no atraviesa s1}
    \label{fig:resultado_wireshark_h4-h1_bloqueado}
\end{figure}

\textbf{Verificación con puerto permitido (8000):}

Para confirmar que el problema es específicamente el puerto 80 y no un error de configuración general, probamos con el puerto 8000:

\begin{verbatim}
mininet> h1 python3 -m http.server 8000 &
mininet> h4 curl http://10.0.0.1:8000
\end{verbatim}

Esta vez la conexión funciona perfectamente:

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{resultado_curl_8000_h4-h1.png}
    \caption{Conexión exitosa en puerto 8000 (no bloqueado)}
    \label{fig:resultado_curl_8000_h4-h1}
\end{figure}

El análisis de Wireshark muestra el handshake TCP completo y el intercambio HTTP normal:

\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{resultado_wireshark_no_bloqueo_h4-h1.png}
    \caption{En puerto 8000 el tráfico fluye sin problemas, confirmando que el firewall es selectivo}
    \label{fig:resultado_wireshark_h4-h1_permitido}
\end{figure}

\subsubsection{Prueba 3: Bloqueo UDP específico - Regla 2}

Esta regla bloquea específicamente el tráfico UDP desde h1 hacia el puerto 5001, pero permite que otros hosts usen ese mismo puerto. En esta prueba verificamos que el firewall filtra por dirección IP origen.

\begin{verbatim}
mininet> h4 iperf -s -u -p 5001 &
mininet> h1 iperf -c 10.0.0.4 -u -p 5001 -t 5  # Bloqueado
mininet> h2 iperf -c 10.0.0.4 -u -p 5001 -t 5  # Permitido
\end{verbatim}

Los resultados muestran claramente la diferencia: h1 envía paquetes pero el servidor no recibe nada (0\%), mientras que h2 tiene comunicación normal (100\%).

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{resultado_iperf_udp.png}
    \caption{Comparación de tráfico UDP. h1 está bloqueado, h2 funciona correctamente}
    \label{fig:resultado_iperf_udp}
\end{figure}

Las capturas de Wireshark en s1-eth1 confirman que el tráfico de h1 no atraviesa el switch, mientras que el de h2 sí:

\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{resultado_wireshark_bloqueo_h1_udp_5001.png}
    \caption{Tráfico UDP de h1 bloqueado: no aparece en la interfaz entre switches}
    \label{fig:resultado_wireshark_h1_udp}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{resultado_wireshark_no_bloqueo_h2_udp_5001.png}
    \caption{Tráfico UDP de h2 permitido: los datagramas atraviesan S1 sin problemas}
    \label{fig:resultado_wireshark_h2_udp}
\end{figure}

\subsubsection{Prueba 4: Bloqueo Bidireccional - Regla 3}

Esta regla bloquea toda comunicación entre h2 y h3, independientemente del protocolo o puerto. Esto simula un aislamiento completo entre dos hosts.

\textbf{Prueba con ICMP:}
\begin{verbatim}
mininet> h2 ping -c 4 h3
mininet> h3 ping -c 4 h2
\end{verbatim}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{pings_h2_h3.png}
    \caption{100\% packet loss en ambas direcciones}
    \label{fig:pings_h2_h3}
\end{figure}

\textbf{Prueba con TCP:}
\begin{verbatim}
mininet> h3 iperf -s &
mininet> h2 iperf -c 10.0.0.3 -t 5
\end{verbatim}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{resultados_iperfs_h2-h3.png}
    \caption{Conexión TCP también bloqueada entre h2 y h3}
    \label{fig:resultados_iperfs_h2-h3}
\end{figure}

Para asegurar que el bloqueo es específico y no un problema general de red, verificamos que ambos hosts pueden comunicarse normalmente con otros:

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{ping_h2-h1.png}
    \caption{h2 puede comunicarse sin problemas con h1}
    \label{fig:ping_h2-h1}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{ping_h3-h4.png}
    \caption{h3 puede comunicarse sin problemas con h4}
    \label{fig:ping_h3-h4}
\end{figure}

\subsection{Escalabilidad: Pruebas con Diferentes Topologías}

Una ventaja del diseño parametrizable es que podemos probar el sistema con distintas configuraciones. Ejecutamos las mismas pruebas de firewall en topologías de diferente tamaño para verificar que todo sigue funcionando.

\subsubsection{Topología con N=1 (Caso Mínimo)}

\begin{verbatim}
./run_topology.sh 1
\end{verbatim}

Con un solo switch, todos los hosts están conectados al mismo equipo (topología estrella). El firewall se instala en S1 y bloquea el tráfico correctamente. Esta configuración es útil para pruebas rápidas y debugging, ya que elimina la complejidad de múltiples saltos.

\subsubsection{Topología con N=3 (Cadena Extendida)}

\begin{verbatim}
./run_topology.sh 3
\end{verbatim}

Con tres switches en cadena, los hosts extremos (h1 en S1 y h4 en S3) están separados por dos saltos. Esta configuración prueba:

\begin{itemize}
    \item \textbf{L2 learning en múltiples switches}: El controlador debe aprender las MACs en cada switch de la cadena
    \item \textbf{Propagación de reglas}: El firewall solo se instala en S1, pero afecta a todo el tráfico que pasa por ahí
    \item \textbf{Latencia}: Como era de esperar, los pings entre h1 y h4 tienen mayor latencia que en N=1 o N=2
\end{itemize}

En ambos casos las reglas del firewall funcionan igual, demostrando que el diseño es robusto y escalable.

\textbf{Nota}: En estas pruebas, todas las reglas están configuradas para aplicarse en el switch S1 (mediante el campo \texttt{"switch": 1} en el archivo JSON). El firewall permite configurar reglas específicas para cada switch según las necesidades de segmentación de la red.